// controllers/studyPlanController.js
const StudyPlan = require('../models/StudyPlan');
const axios = require('axios');
const { validate: isUuid } = require('uuid');

// Generate study plan with ML integration
const generateStudyPlan = async (req, res) => {
  try {
    const { title, description, goals } = req.body;

    // Validate input
    if (!title?.trim() || !Array.isArray(goals) || goals.length === 0) {
      return res.status(400).json({ error: 'Invalid input: title and at least one goal required' });
    }

    // Call ML service
    const mlResponse = await axios.post(
      `${process.env.ML_SERVICE_URL}/generate-tasks`,
      { goals },
      { timeout: process.env.ML_SERVICE_TIMEOUT || 15000 }
    );

    // Validate and transform ML response
    const mlTasks = mlResponse.data?.tasks || [];
    const transformedTasks = mlTasks
      .map((task, index) => {
        try {
          // Basic validation
          if (!task.title || typeof task.duration_hours !== 'number') return null;

          // Calculate dates with staggered start times
          const startDate = new Date(Date.now() + index * 3600000); // 1 hour increments
          const endDate = new Date(startDate.getTime() + task.duration_hours * 3600000);

          return {
            title: task.title,
            description: task.description || `Task related to ${goals.join(', ')}`,
            startDate,
            endDate,
            priority: ['low', 'medium', 'high'].includes(task.priority?.toLowerCase()) 
              ? task.priority.toLowerCase() 
              : 'medium',
            completed: false
          };
        } catch (error) {
          console.warn('Invalid task format:', task);
          return null;
        }
      })
      .filter(Boolean); // Remove invalid tasks

    if (transformedTasks.length === 0) {
      throw new Error('No valid tasks generated by ML service');
    }

    // Create study plan
    const studyPlan = await StudyPlan.create({
      user: req.user.userId,
      title: title.trim(),
      description: description?.trim() || '',
      goals: goals.map(g => g.trim()).filter(Boolean),
      tasks: transformedTasks
    });

    res.status(201).json({
      success: true,
      studyPlan,
      stats: {
        totalTasks: transformedTasks.length,
        highPriority: transformedTasks.filter(t => t.priority === 'high').length,
        totalDuration: transformedTasks.reduce((sum, t) => sum + 
          (t.endDate - t.startDate) / 3600000, 0)
      }
    });

  } catch (error) {
    // Fallback to rule-based generator
    if (process.env.NODE_ENV !== 'production') {
      console.error('ML Service Error:', error.message);
      return generateFallbackStudyPlan(req, res);
    }

    res.status(500).json({
      success: false,
      error: 'Failed to generate study plan',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// Fallback generator (compatible with ML response format)
const generateFallbackStudyPlan = async (req, res) => {
  try {
    const { title, description, goals } = req.body;
    const baseDate = new Date();
    
    const transformedTasks = goals.flatMap((goal, goalIndex) => 
      Array.from({ length: 3 }, (_, i) => ({
        title: `Task ${i + 1} for ${goal}`,
        description: `Essential step ${i + 1} towards ${goal}`,
        startDate: new Date(baseDate.getTime() + (goalIndex * 3 + i) * 3600000),
        endDate: new Date(baseDate.getTime() + (goalIndex * 3 + i + 2) * 3600000),
        priority: ['high', 'medium', 'low'][i],
        completed: false
      }))
    );

    const studyPlan = await StudyPlan.create({
      user: req.user.userId,
      title,
      description,
      goals,
      tasks: transformedTasks
    });

    res.status(201).json({
      success: true,
      studyPlan,
      warning: 'Used fallback generator',
      stats: {
        totalTasks: transformedTasks.length,
        highPriority: transformedTasks.filter(t => t.priority === 'high').length
      }
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to generate fallback study plan'
    });
  }
};

// Helper function to generate tasks from goals
const generateTasksFromGoals = (goals) => {
  const tasks = [];
  const now = new Date();
  
  goals.forEach((goal, index) => {
    // Create 3 tasks per goal
    for (let i = 0; i < 3; i++) {
      const startDate = new Date(now);
      startDate.setDate(now.getDate() + index * 3 + i);
      
      const endDate = new Date(startDate);
      endDate.setHours(startDate.getHours() + 2);
      
      tasks.push({
        title: `Task ${i + 1} for ${goal}`,
        description: `Complete task ${i + 1} to achieve ${goal}`,
        startDate,
        endDate,
        priority: i === 0 ? 'high' : i === 1 ? 'medium' : 'low',
      });
    }
  });
  
  return tasks;
};

// Get all study plans for a user
const getAllStudyPlans = async (req, res) => {
  try {
    const studyPlans = await StudyPlan.find({ user: req.user.userId });
    res.status(200).json({ studyPlans });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// Get a single study plan
const getStudyPlan = async (req, res) => {
  try {
    const { id } = req.params;
    const studyPlan = await StudyPlan.findOne({
      _id: id,
      user: req.user.userId,
    });
    
    if (!studyPlan) {
      return res.status(404).json({ error: `No study plan with id ${id}` });
    }
    
    res.status(200).json({ studyPlan });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

module.exports = {
  generateStudyPlan,
  getAllStudyPlans,
  getStudyPlan,
};